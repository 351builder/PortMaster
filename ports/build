#!/bin/bash
set -e
BRANCH=main
IMAGE_BASE=ghcr.io/pkegg/portmaster
DIR="$(realpath $( dirname "${BASH_SOURCE[0]}" ))"
source ${DIR}/clone-source
export CCACHE_DIR="../.ccache"
function get_linux_platform() {
  local raw_linux_platform
  raw_linux_platform="$(uname -m)"
  if [[ "${raw_linux_platform}" == "x86_64" ]]; then
    echo "linux/amd64"
  elif [[ "${raw_linux_platform}" == "aarch64" ]]; then
    echo "linux/arm64/v8"
  elif  [[ "${raw_linux_platform}" == "armv7l" ]]; then
    echo "linux/arm/v7"
  else
    echo "unknown"
  fi

}
function build_package() {
  local PACKAGE
  PACKAGE="$1"
  local PACKAGE_DIR
  PACKAGE_DIR="$2"
  local SOURCE_DIR="${PACKAGE_DIR}/source"
  local SOURCE_DOCKER_DIR="${PACKAGE}/source"
  local BUILD_DIR
  BUILD_DIR="$(realpath ${PACKAGE_DIR}/..)"

  rm -rf "${PACKAGE_DIR}/pkg"
  mkdir -p "${PACKAGE_DIR}/pkg/"
  PACKAGE_SCRIPT="${PACKAGE_DIR}/package"
  if [[ ! -f "$PACKAGE_SCRIPT" && -f "$PACKAGE_SCRIPT.tmp" ]]; then
    PACKAGE_SCRIPT="$PACKAGE_SCRIPT.tmp"
  fi

  if [[ -f "${PACKAGE_DIR}/build" || -f "${PACKAGE_SCRIPT}" ]]; then

    if [[ -z "${DOCKER_WORK_DIR}" ]]; then
      DOCKER_WORK_DIR=/work
    fi

    GID=$(id -g)
    DOCKER_CMD=docker
  
    # Use 'sudo' if docker ps doesn't work.  In theory, other things than missing sudo could cause this.  But sudo needed is a common issue and easy to fix.
    SUDO=""
    if ! docker ps -q &> /dev/null && sudo docker ps -q &> /dev/null; then
     SUDO="sudo"
    fi
 
    # Launch docker as interactive if this is an interactive shell (allows ctrl-c for manual and running non-interactive - aka: build server)
    INTERACTIVE=""
    if [ -t 0 ]; then
      INTERACTIVE="-it"
    fi
  
    if [[ "${BUILD_IN_DOCKER_IMAGE}" == "true" ]]; then
      echo "building inside docker image"
      build_in_docker_image ${PACKAGE}
    else
      clone_source ${PACKAGE} "${PACKAGE_DIR}"
      if [[ ! -d "${SOURCE_DIR}" ]]; then
        SOURCE_DIR="${PACKAGE_DIR}"
        SOURCE_DOCKER_DIR=""
        BUILD_DIR="."
        mkdir -p "${SOURCE_DIR}"
      fi
      if [[ "$INSTALL_DEPS" == "true" && -f "${PACKAGE_DIR}/install-deps" ]]; then
        if [[ "${USE_DOCKER}" == "false" ]]; then
          echo "Installing dependencies for ${PACKAGE} without docker..."
          pushd "${PACKAGE_DIR}" &> /dev/null
          ESUDO="sudo"
          if ! which sudo &> /dev/null || [[ "$UID" == "0" ]]; then
            ESUDO=""
          fi
          $ESUDO bash "${PACKAGE_DIR}/install-deps"
          popd &> /dev/null
        fi
      fi
      if [[ -f "${PACKAGE_DIR}/build" ]]; then
        if [[ "${USE_DOCKER}" == "false" ]]; then
          linux_platform=$(get_linux_platform)
          if [[ "${BUILD_PLATFORM}" != "${linux_platform}" ]]; then
            echo "--------------------------------------------------------------------------------------------------"
            echo "ERROR: BUILD_PLATFORM is set to ${BUILD_PLATFORM} but current platform is: ${linux_platform} ($(uname -m)"
            echo "  If you are attempting to cross-compile or this is in error, etc.  Please update BUILD_PLATFORM in package.info to: ${linux_platform}"
            exit 1
          fi
          echo "building ${PACKAGE} without docker..."
          pushd "${SOURCE_DIR}" &> /dev/null
          bash "../build"
          popd &> /dev/null
        else
          echo "building ${PACKAGE} with docker..."
          pushd "${SOURCE_DIR}" &> /dev/null

          # Get .env file ready
          env | grep "=" > .env
          ${SUDO} ${DOCKER_CMD} run --platform ${BUILD_PLATFORM} ${INTERACTIVE} --env-file .env --rm --user ${UID}:"${GID}" -v "${BUILD_DIR}:${DOCKER_WORK_DIR}" -w "${DOCKER_WORK_DIR}/${SOURCE_DOCKER_DIR}" ${DOCKER_IMAGE} bash -c "../build"
          popd &> /dev/null
        fi
        echo "build done"
      fi
    fi
  fi

  mkdir -p "${PACKAGE_DIR}/pkg/"

  if [[ -f "${PACKAGE_DIR}/run" ]]; then
    cp "${PACKAGE_DIR}/run" "${PACKAGE_DIR}/pkg/run"
  fi
  cp ${PACKAGE_DIR}/../_global/global-functions "${PACKAGE_DIR}/pkg/"
  cp ${PACKAGE_DIR}/../_global/oga_controls "${PACKAGE_DIR}/pkg/"

  if [[ -f "${PACKAGE_SCRIPT}" ]]; then
    echo "Running custom package script"
    pushd "${PACKAGE_DIR}/" &> /dev/null
    bash ${PACKAGE_SCRIPT}
    popd
  fi

  if [[ -f "${PACKAGE_DIR}/pkg/run" ]] && grep -q IS_TEST_MODE "${PACKAGE_DIR}/pkg/run"; then
    echo "Running ${PACKAGE} run using IS_TEST_MODE=true"
    PORTS_DIR=/opt/roms/ports
    TEST_IMAGE=ghcr.io/pkegg/portmaster/test:${BRANCH}
    docker run ${INTERACTIVE} --rm --platform ${BUILD_PLATFORM} \
      -v "$(realpath ${PACKAGE_DIR}/pkg/):${PORTS_DIR}/${PACKAGE}" \
      -w "${PORTS_DIR}/${PACKAGE}" ${TEST_IMAGE} \
      bash -c "IS_TEST_MODE=true bash \"./run\""
    echo "run test passed"
    
  fi
  
}
function build_env_docker_image() {
  local PACKAGE
  PACKAGE="$1"
  local PACKAGE_DIR
  PACKAGE_DIR="$2"
  local DOCKERFILE
  DOCKERFILE="${PACKAGE_DIR}/Dockerfile"
  if [[ ! -f "${DOCKERFILE}" && -f "${PACKAGE_DIR}/install-deps" ]]; then
    DOCKERFILE="${PACKAGE_DIR}/Dockerfile.deps"
    cp "${PACKAGE_DIR}/../Dockerfile.deps.template" "${DOCKERFILE}"
  fi
  if [[ -f "${DOCKERFILE}" ]]; then
    echo "${DOCKERFILE} exists"

    DOCKER_IMAGE_CACHE=${IMAGE_BASE}/${PACKAGE}/cache:${BRANCH}
  
    if [[ "${USE_DOCKER_PUSH}" == "true" ]]; then
      IMAGE_CACHE_TO="--pull --cache-to=type=registry,ref=${DOCKER_IMAGE_CACHE},mode=max --push"
    else
      IMAGE_CACHE_TO="--load --builder default"
    fi
    IMAGE_CACHE_FROM="--cache-from=type=registry,ref=${DOCKER_IMAGE_CACHE}"


    #make lower case as docker must be lowers
    #DOCKER_IMAGE=$(echo "$DOCKER_IMAGE" | tr '[:upper:]' '[:lower:]')

    echo "docker image: ${DOCKER_IMAGE}"

    if [[ "${USE_DOCKER}" != "false" ]]; then
      pushd "${PACKAGE_DIR}" &> /dev/null

      docker buildx build --platform ${BUILD_PLATFORM} \
        --tag "${DOCKER_IMAGE}" \
        -f "${DOCKERFILE}" \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .
      popd &> /dev/null
      echo "tagged: ${DOCKER_IMAGE}"
    fi 
  else
    echo "${PACKAGE_DIR}/Dockerfile does not exist"
    DOCKER_IMAGE=${IMAGE_BASE}:main
  fi
}
function build_in_docker_image() {

    local PACKAGE
    PACKAGE="$1"
    echo "Copying ${DIR}/Dockerfile.build.template"
    cp "${DIR}/Dockerfile.build.template" ${DIR}/${PACKAGE}/Dockerfile.build
    cp "${DIR}/clone-source" "${DIR}/${PACKAGE}/clone-source"

    DOCKER_IMAGE_BUILD=${IMAGE_BASE}/${PACKAGE}/build:${BRANCH}
    DOCKER_IMAGE_BUILD_CACHE=${IMAGE_BASE}/${PACKAGE}/build/cache:${BRANCH}

    #make lower case as docker must be lowers
    DOCKER_IMAGE_BUILD=$(echo "$DOCKER_IMAGE_BUILD" | tr '[:upper:]' '[:lower:]')
    DOCKER_IMAGE_BUILD_CACHE=$(echo "$DOCKER_IMAGE_BUILD_CACHE" | tr '[:upper:]' '[:lower:]')

    if [[ "${USE_DOCKER_PUSH}" == "true" ]]; then
      IMAGE_CACHE_TO="--pull --cache-to=type=registry,ref=${DOCKER_IMAGE_BUILD_CACHE},mode=max --push"
    fi
    IMAGE_CACHE_FROM="--cache-from=type=registry,ref=${DOCKER_IMAGE_BUILD_CACHE}"
    pushd "${PACKAGE_DIR}" &> /dev/null
    echo docker buildx build --platform ${BUILD_PLATFORM} \
        -f Dockerfile.build --tag "${DOCKER_IMAGE_BUILD}" \
        --build-arg DOCKER_IMAGE=${DOCKER_IMAGE} \
        --build-arg PACKAGE=${PACKAGE} \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .

    docker buildx build --platform ${BUILD_PLATFORM} \
        -f Dockerfile.build --tag "${DOCKER_IMAGE_BUILD}" \
        --build-arg DOCKER_IMAGE=${DOCKER_IMAGE} \
        --build-arg PACKAGE=${PACKAGE} \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .

    
    ID=$(docker create ${DOCKER_IMAGE_BUILD})
    rm -rf ./pkg
    rm -rf ./source
    echo "copying built images (./pkg)" 
    docker cp "${ID}:/work/${PACKAGE}/pkg" ./pkg || true # it is OK (at least for now) if there's not a package inside
    
    echo "copying built images (./pkg)" 
    docker cp "${ID}:/work/${PACKAGE}/source" ./source || true # it is OK (at least for now) if there's not a source fodler inside

    echo "done"
    docker rm -f "${ID}"

    popd &> /dev/null


}
function parse_args() {
  BUILD_IN_DOCKER_IMAGE=false
  USE_DOCKER=true
  USE_DOCKER_PUSH=false
  INSTALL_DEPS=false
  
  # Parse args
  ARGS=()
  while [[ $# -gt 0 ]]; do
    key="$1"
  
    case $key in
      -i|--docker-image)
        BUILD_IN_DOCKER_IMAGE="true"
        shift # past argument
        ;;
      -n|--no-docker)
        USE_DOCKER="false"
        shift # past argument
        ;;
      -d|--install-deps)
        INSTALL_DEPS="true"
        shift # past argument
        ;;
      -p|--push)
        USE_DOCKER_PUSH="true"
        shift # past argument
        ;;
      -h|--help)
        echo "$0 <package> [arguments]"
        echo "  --docker-image (-i) - builds ports in a Dockerfile (./build).  Allows caching.  Used for build server and troubleshooting build server"
        echo "  --no-docker (-n) - Runs ./build script directly without docker overhead.  For troubleshooting and internal use as part of --docker-image"
        echo "  --install-deps (-d) - Runs the ./install-deps script automatically using 'sudo' if 'sudo' binary exists and the user is not root.  Only needed with --no-docker"
        echo "  --push (-p) - pushes docker images.  Meant for build server"
        exit 1
        ;;
      *)    # unknown option
        ARGS+=("$1") # save it in an array for later
        shift # past argument
        ;;
    esac
  done

  if [[ "$USE_DOCKER" == "true" ]] && ! which docker &> /dev/null; then
    echo "WARNING: docker not found.  Assuming: --no-docker which means you must manually run in a chroot or only run cross-compile builds"
    sleep 1
    USE_DOCKER=false
  fi 
}
 

# don't run anything if being sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  PACKAGE=$1
  echo "building package: $PACKAGE"
  shift
  parse_args "$@"
  
  PACKAGE_DIR="$(realpath "ports/${PACKAGE}")"
  BUILD_PLATFORM=""

  source "${PACKAGE_DIR}/package.info"

  if [[ "${LEGACY_PORTMASTER}" == "true" ]]; then
    source "${PACKAGE_DIR}/../ports.info"
    
    # LEGACY_PORTMASTER doesn't 'build' anything (as build files are in legacy zips), so just use the current
    # platform for max speed in packaging, etc.
    BUILD_PLATFORM="$(get_linux_platform)"

    PACKAGE_INFO_TMP="${PACKAGE_DIR}/package.info.tmp"

    if [[ -z "${PKG_DOWNLOAD_NAME}" ]]; then
      PKG_DOWNLOAD_NAME="${PKG_NAME}"
    fi
    echo "Legacy Portmaster Build - Getting info from legacy URLS"

    GITHUB_AUTH=""
    if [[ -n "${GITHUB_TOKEN}" ]]; then
      GITHUB_AUTH="Authorization: token ${GITHUB_TOKEN}"
    fi
    
    if [[ -z "$LEGACY_URL_OVERRIDE" ]]; then

      GITHUB_SHA_URL="https://api.github.com/repos/${LEGACY_PORTMASTER_ORG}/${LEGACY_PORTMASTER_REPO}/contents?sha=${LEGACY_PORTMASTER_BRANCH}&path=/&page=1&per_page=1"
      PKG_VERSION_URL="https://api.github.com/repos/${LEGACY_PORTMASTER_ORG}/${LEGACY_PORTMASTER_REPO}/commits?sha=${LEGACY_PORTMASTER_BRANCH}&page=1&per_page=1"
      echo "Github SHA URL: ${GITHUB_SHA_URL} PKG_DOWNLOAD_NAME: ${PKG_DOWNLOAD_NAME}"
      PKG_GIT_SHA=$(curl -H "${GITHUB_AUTH}" -L "${GITHUB_SHA_URL}" -q 2> /dev/null | grep -i "${PKG_DOWNLOAD_NAME}.zip" -A 3 | grep -i "\"sha\"" | head -1 | sed -E 's|.*: "(.*)",|\1|g')
      if [[ -z "${PKG_GIT_SHA}" ]]; then
        echo "debug info: curl -H '${GITHUB_AUTH}' -L '${GITHUB_SHA_URL}'' -q"
        echo "Could not find ${PKG_NAME}.zip in ${GITHUB_SHA_URL}"
        
        exit 1
      fi
      echo "Package Version URL: ${PKG_VERSION_URL}"

      PKG_VERSION=$(curl -G -H "${GITHUB_AUTH}" -L "${PKG_VERSION_URL}" --data-urlencode "path=${PKG_DOWNLOAD_NAME}.zip" -q 2> /dev/null | grep -i sha | head -1 | sed -E 's|.*: "(.*)",|\1|g')
      if [[ -z "${PKG_VERSION}" ]]; then
        echo "debug info: curl -H '${GITHUB_AUTH}' -L '${PKG_VERSION_URL}' --data-urlencode 'path=${PKG_DOWNLOAD_NAME}.zip' -q 2>&1 )"
        echo "Could not find a sha in: ${GITHUB_SHA_URL}"
        exit 1
      fi
      PKG_URL="https://github.com/${LEGACY_PORTMASTER_ORG}/${LEGACY_PORTMASTER_REPO}/raw/${PKG_VERSION}/${PKG_DOWNLOAD_NAME}.zip"
  
    else
      PKG_URL="${LEGACY_URL_OVERRIDE}"
    fi
    GET_HANDLER_SUPPORT="archive"
    echo "PKG_GIT_SHA: ${PKG_GIT_SHA} PKG_VERSION: ${PKG_VERSION} PKG_URL: ${PKG_URL}"

    rm -rf "${PACKAGE_INFO_TMP}"
    echo "PKG_GIT_SHA=\"${PKG_GIT_SHA}\"" >> "${PACKAGE_INFO_TMP}"
    echo "PKG_VERSION=\"${PKG_VERSION}\"" >> "${PACKAGE_INFO_TMP}"
    echo "PKG_URL=\"${PKG_URL}\"" >> "${PACKAGE_INFO_TMP}"
    echo "GET_HANDLER_SUPPORT=\"${GET_HANDLER_SUPPORT}\"" >> "${PACKAGE_INFO_TMP}"

    cp "${PACKAGE_DIR}/../package.legacy.template" "${PACKAGE_DIR}/package.tmp"
  fi

  # Default BUILD_PLATFORM to arm64 unless set in package.info or by LEGACY_PORTMASTER
  if [[ -z "$BUILD_PLATFORM" ]]; then
    BUILD_PLATFORM="linux/arm64/v8"
  fi

  echo "BUILD_IN_DOCKER_IMAGE: ${BUILD_IN_DOCKER_IMAGE} USE_DOCKER: ${USE_DOCKER} USE_DOCKER_PUSH: ${USE_DOCKER_PUSH} BUILD_PLATFORM: ${BUILD_PLATFORM}"
  DOCKER_IMAGE=${IMAGE_BASE}/${PACKAGE}:${BRANCH}

  build_env_docker_image "$PACKAGE" "$PACKAGE_DIR"
  build_package "$PACKAGE" "$PACKAGE_DIR"
  
  RELEASE_DIR="$(realpath ${PACKAGE_DIR}/../../release)"
  GLOBAL_DIR="$(realpath ${PACKAGE_DIR}/../_global)"
  pushd "${PACKAGE_DIR}/pkg" &> /dev/null

  echo "Release dir: ${RELEASE_DIR}"
  ZIP_FILE="${RELEASE_DIR}/${PKG_NAME}.zip"
  mkdir -p "${RELEASE_DIR}"
  rm -rf "${RELEASE_DIR:?}/${PKG_NAME}"
  rm -rf "${RELEASE_DIR:?}/${PKG_NAME}.zip"

  echo "Preparing release zip..."

  mkdir -p "${RELEASE_DIR:?}/${PKG_NAME}/"
  PKG_DIRECTORY="${PACKAGE}"
  if [[ -n "${PKG_DIRECTORY_OVERRIDE}" ]]; then
    PKG_DIRECTORY="$PKG_DIRECTORY_OVERRIDE"
  fi
  if [[ -f "${PACKAGE_DIR}/run-legacy.sh" ]]; then
    cp "${PACKAGE_DIR}/run-legacy.sh" "${RELEASE_DIR}/${PKG_NAME}/${PKG_NAME}.sh"
  elif [[ "${LEGACY_PORTMASTER}"  == "true" \
         && -f "${PACKAGE_DIR}/source/${PKG_NAME}.sh" \
         && ! -f "${PACKAGE_DIR}/run" ]]; then
    cp "${PACKAGE_DIR}/source/${PKG_NAME}.sh" "${RELEASE_DIR}/${PKG_NAME}/${PKG_NAME}.sh"
  else
    cp "${GLOBAL_DIR}/global-run.sh" "${RELEASE_DIR}/${PKG_NAME}/${PKG_NAME}.sh"
    sed -i.bak "s/__PACKAGE__/${PACKAGE}/g" "${RELEASE_DIR}/${PKG_NAME}/${PKG_NAME}.sh"
  fi

  cp -r "./" "${RELEASE_DIR}/${PKG_NAME}/${PKG_DIRECTORY}"
  popd &> /dev/null

  pushd "${RELEASE_DIR}/${PKG_NAME}" &> /dev/null || exit 1
  echo "Zipping..."
  zip -FSqr "${ZIP_FILE}" .
  popd &> /dev/null

  echo "========================================="
  echo "Build done: ${PACKAGE}.  Zip: ${ZIP_FILE}"
  echo ""
fi
