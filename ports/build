#!/bin/bash
set -e
BRANCH=main
IMAGE_BASE=ghcr.io/pkegg/portmaster
DIR="$(realpath $( dirname "${BASH_SOURCE[0]}" ))"
source ${DIR}/clone-source
export CCACHE_DIR="../.ccache"

function build_package() {
  local PACKAGE
  PACKAGE="$1"
  local PACKAGE_DIR
  PACKAGE_DIR="$2"
  local SOURCE_DIR="${PACKAGE_DIR}/source"
  local SOURCE_DOCKER_DIR="${PACKAGE}/source"
  local BUILD_DIR
  BUILD_DIR="$(realpath ${PACKAGE_DIR}/..)"

  rm -rf "${PACKAGE_DIR}/pkg"
  mkdir -p "${PACKAGE_DIR}/pkg/"
  PACKAGE_SCRIPT="${PACKAGE_DIR}/package"
  if [[ ! -x "$PACKAGE_SCRIPT" && -x "$PACKAGE_SCRIPT.tmp" ]]; then
    PACKAGE_SCRIPT="$PACKAGE_SCRIPT.tmp"
  fi

  if [[ -x "${PACKAGE_DIR}/build" || -x "${PACKAGE_SCRIPT}" ]]; then

    if [[ -z "${DOCKER_WORK_DIR}" ]]; then
      DOCKER_WORK_DIR=/work
    fi

    GID=$(id -g)
    DOCKER_CMD=docker
  
    # Use 'sudo' if docker ps doesn't work.  In theory, other things than missing sudo could cause this.  But sudo needed is a common issue and easy to fix.
    SUDO=""
    if ! docker ps -q &> /dev/null && sudo docker ps -q &> /dev/null; then
     SUDO="sudo"
    fi
 
    # Launch docker as interactive if this is an interactive shell (allows ctrl-c for manual and running non-interactive - aka: build server)
    INTERACTIVE=""
    if [ -t 0 ]; then
      INTERACTIVE="-it"
    fi
  
    if [[ "${BUILD_IN_DOCKER_IMAGE}" == "true" ]]; then
      echo "building inside docker image"
      build_in_docker_image ${PACKAGE}
    else
      clone_source ${PACKAGE} "${PACKAGE_DIR}"
      if [[ ! -d "${SOURCE_DIR}" ]]; then
        SOURCE_DIR="${PACKAGE_DIR}"
        SOURCE_DOCKER_DIR=""
        BUILD_DIR="."
        mkdir -p "${SOURCE_DIR}"
      fi
      if [[ -x "${PACKAGE_DIR}/build" ]]; then
        if [[ "${USE_DOCKER}" == "false" ]]; then
          echo "building ${PACKAGE} without docker..."
          pushd "${SOURCE_DIR}" &> /dev/null
          "${BUILD_DIR}/build"
          popd &> /dev/null
        else
          echo "building ${PACKAGE} with docker..."
          pushd "${SOURCE_DIR}" &> /dev/null

          # Get .env file ready
          env | grep "=" > .env
          ${SUDO} ${DOCKER_CMD} run --platform ${BUILD_PLATFORM} ${INTERACTIVE} --env-file .env --rm --user ${UID}:"${GID}" -v "${BUILD_DIR}:${DOCKER_WORK_DIR}" -w "${DOCKER_WORK_DIR}/${SOURCE_DOCKER_DIR}" ${DOCKER_IMAGE} bash -c "../build"
          popd &> /dev/null
        fi
        echo "build done"
      fi
    fi
  fi

  mkdir -p "${PACKAGE_DIR}/pkg/"

  if [[ -f "${PACKAGE_DIR}/run.sh" ]]; then
    cp "${PACKAGE_DIR}/run.sh" "${PACKAGE_DIR}/pkg/run.sh"
  fi
  cp ${PACKAGE_DIR}/../_global/global-functions "${PACKAGE_DIR}/pkg/"
  cp ${PACKAGE_DIR}/../_global/oga_controls "${PACKAGE_DIR}/pkg/"

  if [[ -x "${PACKAGE_SCRIPT}" ]]; then
    echo "Running custom package script"
    pushd "${PACKAGE_DIR}/" &> /dev/null
    ${PACKAGE_SCRIPT}
    popd
  fi

  if [[ -f "${PACKAGE_DIR}/pkg/run.sh" ]] && grep -q IS_TEST_MODE "${PACKAGE_DIR}/pkg/run.sh"; then
    echo "Running ${PACKAGE} run.sh using IS_TEST_MODE=true"
    PORTS_DIR=/opt/roms/ports
    TEST_IMAGE=ghcr.io/pkegg/portmaster/test:${BRANCH}
    docker run ${INTERACTIVE} --rm --platform ${BUILD_PLATFORM} \
      -v "$(realpath ${PACKAGE_DIR}/pkg/):${PORTS_DIR}/${PACKAGE}" \
      -w "${PORTS_DIR}/${PACKAGE}" ${TEST_IMAGE} \
      bash -c "IS_TEST_MODE=true bash \"./run.sh\""
    echo "run.sh test passed"
    
  fi
  
}
function build_env_docker_image() {
  local PACKAGE
  PACKAGE="$1"
  local PACKAGE_DIR
  PACKAGE_DIR="$2"
  if [[ -f "${PACKAGE_DIR}/Dockerfile" ]]; then
    echo "${PACKAGE_DIR}/Dockerfile exists"

    DOCKER_IMAGE_CACHE=${IMAGE_BASE}/${PACKAGE}/cache:${BRANCH}
  
    if [[ "${USE_DOCKER_PUSH}" == "true" ]]; then
      IMAGE_CACHE_TO="--pull --cache-to=type=registry,ref=${DOCKER_IMAGE_CACHE},mode=max --push"
    else
      IMAGE_CACHE_TO="--load --builder default"
    fi
    IMAGE_CACHE_FROM="--cache-from=type=registry,ref=${DOCKER_IMAGE_CACHE}"


    #make lower case as docker must be lowers
    #DOCKER_IMAGE=$(echo "$DOCKER_IMAGE" | tr '[:upper:]' '[:lower:]')

    echo "docker image: ${DOCKER_IMAGE}"

    if [[ "${USE_DOCKER}" != "false" ]]; then
      pushd "${PACKAGE_DIR}" &> /dev/null
      echo docker buildx build --platform ${BUILD_PLATFORM} \
        --tag "${DOCKER_IMAGE}" \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .

      docker buildx build --platform ${BUILD_PLATFORM} \
        --tag "${DOCKER_IMAGE}" \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .
      popd &> /dev/null
      echo "tagged: ${DOCKER_IMAGE}"
    fi 
  else
    echo "${PACKAGE_DIR}/Dockerfile does not exist"
    DOCKER_IMAGE=${IMAGE_BASE}:main
  fi
}
function build_in_docker_image() {

    local PACKAGE
    PACKAGE="$1"
    echo "Copying ${DIR}/Dockerfile.build.template"
    cp "${DIR}/Dockerfile.build.template" ${DIR}/${PACKAGE}/Dockerfile.build
    cp "${DIR}/clone-source" "${DIR}/${PACKAGE}/clone-source"

    DOCKER_IMAGE_BUILD=${IMAGE_BASE}/${PACKAGE}/build:${BRANCH}
    DOCKER_IMAGE_BUILD_CACHE=${IMAGE_BASE}/${PACKAGE}/build/cache:${BRANCH}

    #make lower case as docker must be lowers
    DOCKER_IMAGE_BUILD=$(echo "$DOCKER_IMAGE_BUILD" | tr '[:upper:]' '[:lower:]')
    DOCKER_IMAGE_BUILD_CACHE=$(echo "$DOCKER_IMAGE_BUILD_CACHE" | tr '[:upper:]' '[:lower:]')

    if [[ "${USE_DOCKER_PUSH}" == "true" ]]; then
      IMAGE_CACHE_TO="--pull --cache-to=type=registry,ref=${DOCKER_IMAGE_BUILD_CACHE},mode=max --push"
    fi
    IMAGE_CACHE_FROM="--cache-from=type=registry,ref=${DOCKER_IMAGE_BUILD_CACHE}"
    pushd "${PACKAGE_DIR}" &> /dev/null
    echo docker buildx build --platform ${BUILD_PLATFORM} \
        -f Dockerfile.build --tag "${DOCKER_IMAGE_BUILD}" \
        --build-arg DOCKER_IMAGE=${DOCKER_IMAGE} \
        --build-arg PACKAGE=${PACKAGE} \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .

    docker buildx build --platform ${BUILD_PLATFORM} \
        -f Dockerfile.build --tag "${DOCKER_IMAGE_BUILD}" \
        --build-arg DOCKER_IMAGE=${DOCKER_IMAGE} \
        --build-arg PACKAGE=${PACKAGE} \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .

    
    ID=$(docker create ${DOCKER_IMAGE_BUILD})
    rm -rf ./pkg
    rm -rf ./source
    echo "copying built images (./pkg)" 
    docker cp "${ID}:/work/${PACKAGE}/pkg" ./pkg || true # it is OK (at least for now) if there's not a package inside
    
    echo "copying built images (./pkg)" 
    docker cp "${ID}:/work/${PACKAGE}/source" ./source || true # it is OK (at least for now) if there's not a source fodler inside

    echo "done"
    docker rm -f "${ID}"

    popd &> /dev/null


}
function parse_args() {
  BUILD_IN_DOCKER_IMAGE=false
  USE_DOCKER=true
  USE_DOCKER_PUSH=false
  
  # Parse args
  ARGS=()
  while [[ $# -gt 0 ]]; do
    key="$1"
  
    case $key in
      -i|--docker-image)
        BUILD_IN_DOCKER_IMAGE="true"
        shift # past argument
        ;;
      -n|--no-docker)
        USE_DOCKER="false"
        shift # past argument
        ;;
      -p|--push)
        USE_DOCKER_PUSH="true"
        shift # past argument
        ;;
      -h|--help)
        echo "$0 <package> [arguments]"
        echo "  --docker-image (-i) - builds ports in a Dockerfile (./build).  Allows caching.  Used for build server and troubleshooting build server"
        echo "  --no-docker (-n) - Runs ./build script directly without docker overhead.  For troubleshooting and internal use as part of --docker-image"
        echo "  --push (-p) - pushes docker images.  Meant for build server"
        exit 1
        ;;
      *)    # unknown option
        ARGS+=("$1") # save it in an array for later
        shift # past argument
        ;;
    esac
  done
}
 

# don't run anything if being sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  PACKAGE=$1
  echo "building package: $PACKAGE"
  shift
  parse_args "$@"
  
  PACKAGE_DIR="$(realpath "ports/${PACKAGE}")"

  source "${PACKAGE_DIR}/package.info"

  if [[ "${LEGACY_PORTMASTER}" == "true" ]]; then
    source "${PACKAGE_DIR}/../ports.info"
    PACKAGE_INFO_TMP="${PACKAGE_DIR}/package.info.tmp"

    echo "Legacy Portmaster Build - Getting info from legacy URLS"

    PKG_GIT_SHA=$(curl -L "https://api.github.com/repos/${LEGACY_PORTMASTER_ORG}/${LEGACY_PORTMASTER_REPO}/contents?sha=${LEGACY_PORTMASTER_BRANCH}&path=/&page=1&per_page=1" -q 2> /dev/null | grep "${PKG_NAME}.zip" -A 2 | grep -i sha | head -1 | sed -E 's|.*: "(.*)",|\1|g')
    PKG_VERSION=$(wget -O- "https://api.github.com/repos/${LEGACY_PORTMASTER_ORG}/${LEGACY_PORTMASTER_REPO}/commits?sha=${LEGACY_PORTMASTER_BRANCH}&path=${PKG_NAME}.zip&page=1&per_page=1" -q 2> /dev/null | grep -i sha | head -1 | sed -E 's|.*: "(.*)",|\1|g')

    PKG_URL="https://github.com/${LEGACY_PORTMASTER_ORG}/${LEGACY_PORTMASTER_REPO}/raw/${PKG_VERSION}/${PKG_NAME}.zip"
    GET_HANDLER_SUPPORT="archive"
    echo "PKG_GIT_SHA: ${PKG_GIT_SHA} PKG_VERSION: ${PKG_VERSION} PKG_URL: ${PKG_URL}"

    rm -rf "${PACKAGE_INFO_TMP}"
    echo "PKG_GIT_SHA=\"${PKG_GIT_SHA}\"" >> "${PACKAGE_INFO_TMP}"
    echo "PKG_VERSION=\"${PKG_VERSION}\"" >> "${PACKAGE_INFO_TMP}"
    echo "PKG_URL=\"${PKG_URL}\"" >> "${PACKAGE_INFO_TMP}"
    echo "GET_HANDLER_SUPPORT=\"${GET_HANDLER_SUPPORT}\"" >> "${PACKAGE_INFO_TMP}"

    cp "${PACKAGE_DIR}/../package.legacy.template" "${PACKAGE_DIR}/package.tmp"
  fi

  if [[ -z "$BUILD_PLATFORM" ]]; then
    BUILD_PLATFORM="linux/arm64/v8"
  fi
  echo "BUILD_IN_DOCKER_IMAGE: ${BUILD_IN_DOCKER_IMAGE} USE_DOCKER: ${USE_DOCKER} USE_DOCKER_PUSH: ${USE_DOCKER_PUSH} BUILD_PLATFORM: ${BUILD_PLATFORM}"
  DOCKER_IMAGE=${IMAGE_BASE}/${PACKAGE}:${BRANCH}

  build_env_docker_image "$PACKAGE" "$PACKAGE_DIR"
  build_package "$PACKAGE" "$PACKAGE_DIR"
  
  RELEASE_DIR="$(realpath ${PACKAGE_DIR}/../../release)"
  GLOBAL_DIR="$(realpath ${PACKAGE_DIR}/../_global)"
  pushd "${PACKAGE_DIR}/pkg" &> /dev/null

  echo "Release dir: ${RELEASE_DIR}"
  ZIP_FILE="${RELEASE_DIR}/${PKG_NAME}.zip"
  mkdir -p "${RELEASE_DIR}"
  rm -rf "${RELEASE_DIR:?}/${PKG_NAME}"
  rm -rf "${RELEASE_DIR:?}/${PKG_NAME}.zip"

  echo "Preparing release zip..."

  mkdir -p "${RELEASE_DIR:?}/${PKG_NAME}/"
  PKG_DIRECTORY="${PACKAGE}"
  if [[ -n "${PKG_DIRECTORY_OVERRIDE}" ]]; then
    PKG_DIRECTORY="$PKG_DIRECTORY_OVERRIDE"
  fi
  if [[ -f "${PACKAGE_DIR}/run-legacy.sh" ]]; then
    cp "${PACKAGE_DIR}/run-legacy.sh" "${RELEASE_DIR}/${PKG_NAME}/${PKG_NAME}.sh"
  elif [[ "${LEGACY_PORTMASTER}"  == "true" && -f "${PACKAGE_DIR}/source/${PKG_NAME}.sh" ]]; then
    cp "${PACKAGE_DIR}/source/${PKG_NAME}.sh" "${RELEASE_DIR}/${PKG_NAME}/${PKG_NAME}.sh"
  else
    cp "${GLOBAL_DIR}/global-run.sh" "${RELEASE_DIR}/${PKG_NAME}/${PKG_NAME}.sh"
    sed -i "s/__PACKAGE__/${PACKAGE}/g" "${RELEASE_DIR}/${PKG_NAME}/${PKG_NAME}.sh"
  fi

  cp -r "./" "${RELEASE_DIR}/${PKG_NAME}/${PKG_DIRECTORY}"
  popd &> /dev/null

  pushd "${RELEASE_DIR}/${PKG_NAME}" &> /dev/null || exit 1
  echo "Zipping..."
  zip -FSqr "${ZIP_FILE}" .
  popd &> /dev/null

  echo "========================================="
  echo "Build done: ${PACKAGE}.  Zip: ${ZIP_FILE}"
  echo ""
fi
