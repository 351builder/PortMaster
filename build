#!/bin/bash
set -e
BRANCH=main
IMAGE_BASE=ghcr.io/pkegg/portmaster
DIR="$(realpath $(dirname "${BASH_SOURCE[0]}"))"  # Get the directory name
source ${DIR}/clone-source
export CCACHE_DIR="../.ccache"

function build_package() {
  local PACKAGE
  PACKAGE="$1"
  local PACKAGE_DIR
  PACKAGE_DIR="$(realpath "${PACKAGE}")"
  local PACKAGE_MK="${PACKAGE}/package.info"
  local SOURCE_DIR="${PACKAGE}/source"
  local SOURCE_DOCKER_DIR=source
  local BUILD_DIR=".."
  source "${PACKAGE_MK}"

  rm -rf ./pkg

  if [[ -x "${PACKAGE}/build" || -x "${PACKAGE}/package" ]]; then

    if [[ -z "${DOCKER_WORK_DIR}" ]]; then
      DOCKER_WORK_DIR=/work
    fi

    GID=$(id -g)
    DOCKER_CMD=docker
  
    # Use 'sudo' if docker ps doesn't work.  In theory, other things than missing sudo could cause this.  But sudo needed is a common issue and easy to fix.
    SUDO=""
    if ! docker ps -q &> /dev/null && sudo docker ps -q &> /dev/null; then
     SUDO="sudo"
    fi
 
    # Launch docker as interactive if this is an interactive shell (allows ctrl-c for manual and running non-interactive - aka: build server)
    INTERACTIVE=""
    if [ -t 0 ]; then
      INTERACTIVE="-it"
    fi
 
  
    if [[ -x "${PACKAGE}/build" ]]; then
      if [[ "${BUILD_IN_DOCKER_IMAGE}" == "true" ]]; then
        echo "building inside docker image"
        build_in_docker_image ${PACKAGE}
      else
        clone_source ${PACKAGE}
        if [[ "${USE_DOCKER}" == "false" ]]; then
          echo "building ${PACKAGE} without docker..."
          pushd "${SOURCE_DIR}" &> /dev/null
          "${BUILD_DIR}/build"
          popd &> /dev/null
        else
          echo "building ${PACKAGE} with docker..."
          pushd "${SOURCE_DIR}" &> /dev/null

          # Get .env file ready
          env | grep "=" > .env
          ${SUDO} ${DOCKER_CMD} run --platform ${BUILD_PLATFORM} ${PODMAN_ARGS} ${INTERACTIVE} --env-file .env --rm --user ${UID}:"${GID}" -v "${PWD}/${BUILD_DIR}:${DOCKER_WORK_DIR}" -w "${DOCKER_WORK_DIR}/${SOURCE_DOCKER_DIR}" ${DOCKER_IMAGE} bash -c "${BUILD_DIR}/build"
          popd &> /dev/null
        fi
      fi
      echo "build done"
    fi
  fi

  mkdir -p "${PACKAGE_DIR}/pkg/${PACKAGE}"

  if [[ -f "${PACKAGE_DIR}/run.sh" ]]; then
    cp "${PACKAGE_DIR}/run.sh" "${PACKAGE_DIR}/pkg/${PKG_NAME}.sh"
  fi
  cp -r ${PACKAGE_DIR}/../_global/* "${PACKAGE_DIR}/pkg/${PACKAGE}"

  if [[ -x "${PACKAGE_DIR}/package" ]]; then
    echo "Running custom package script"
    pushd "${PACKAGE_DIR}/" &> /dev/null
    ${PACKAGE_DIR}/package
    popd
  fi
  
}
function build_env_docker_image() {
  local PACKAGE
  PACKAGE=$1
  if [[ -f "${PACKAGE}/Dockerfile" ]]; then
    echo "${PACKAGE}/Dockerfile exists"

    DOCKER_IMAGE_CACHE=${IMAGE_BASE}/${PACKAGE}/cache:${BRANCH}
  
    if [[ "${USE_DOCKER_PUSH}" == "true" ]]; then
      IMAGE_CACHE_TO="--pull --cache-to=type=registry,ref=${DOCKER_IMAGE_CACHE},mode=max --push"
    else
      IMAGE_CACHE_TO="--load --builder default"
    fi
    IMAGE_CACHE_FROM="--cache-from=type=registry,ref=${DOCKER_IMAGE_CACHE}"


    #make lower case as docker must be lowers
    #DOCKER_IMAGE=$(echo "$DOCKER_IMAGE" | tr '[:upper:]' '[:lower:]')

    echo "docker image: ${DOCKER_IMAGE}"

    if [[ "${USE_DOCKER}" != "false" ]]; then
      pushd "${PACKAGE}" &> /dev/null
      echo docker buildx build --platform ${BUILD_PLATFORM} \
        --tag "${DOCKER_IMAGE}" \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .

      docker buildx build --platform ${BUILD_PLATFORM} \
        --tag "${DOCKER_IMAGE}" \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .
      popd &> /dev/null
      echo "tagged: ${DOCKER_IMAGE}"
    fi 
  else
    echo "${PACKAGE}/Dockerfile does not exist"
    DOCKER_IMAGE=${IMAGE_BASE}:main
  fi
}
function build_in_docker_image() {

    local PACKAGE
    PACKAGE="$1"
    echo "Copying ${DIR}/Dockerfile.build.template"
    cp "${DIR}/Dockerfile.build.template" ${DIR}/${PACKAGE}/Dockerfile.build
    cp "${DIR}/clone-source" "${DIR}/${PACKAGE}/clone-source"

    DOCKER_IMAGE_BUILD=${IMAGE_BASE}/${PACKAGE}/build:${BRANCH}
    DOCKER_IMAGE_BUILD_CACHE=${IMAGE_BASE}/${PACKAGE}/build/cache:${BRANCH}

    #make lower case as docker must be lowers
    DOCKER_IMAGE_BUILD=$(echo "$DOCKER_IMAGE_BUILD" | tr '[:upper:]' '[:lower:]')
    DOCKER_IMAGE_BUILD_CACHE=$(echo "$DOCKER_IMAGE_BUILD_CACHE" | tr '[:upper:]' '[:lower:]')

    if [[ "${USE_DOCKER_PUSH}" == "true" ]]; then
      IMAGE_CACHE_TO="--pull --cache-to=type=registry,ref=${DOCKER_IMAGE_BUILD_CACHE},mode=max --push"
    fi
    IMAGE_CACHE_FROM="--cache-from=type=registry,ref=${DOCKER_IMAGE_BUILD_CACHE}"
    pushd "${PACKAGE}" &> /dev/null
    echo docker buildx build --platform ${BUILD_PLATFORM} \
        -f Dockerfile.build --tag "${DOCKER_IMAGE_BUILD}" \
        --build-arg DOCKER_IMAGE=${DOCKER_IMAGE} \
        --build-arg PACKAGE=${PACKAGE} \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .

    docker buildx build --platform ${BUILD_PLATFORM} \
        -f Dockerfile.build --tag "${DOCKER_IMAGE_BUILD}" \
        --build-arg DOCKER_IMAGE=${DOCKER_IMAGE} \
        --build-arg PACKAGE=${PACKAGE} \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .

    
    ID=$(docker create ${DOCKER_IMAGE_BUILD})
    rm -rf ./pkg
    echo "copying built images (./pkg)" 
    docker cp "${ID}:/${PACKAGE}/*" ./ || true # it is OK (at least for now) if there's not a package inside
    echo "done"
    docker rm -f "${ID}"

    popd &> /dev/null


}
function parse_args() {
  BUILD_IN_DOCKER_IMAGE=false
  USE_DOCKER=true
  USE_DOCKER_PUSH=false
  
  # Parse args
  ARGS=()
  while [[ $# -gt 0 ]]; do
    key="$1"
  
    case $key in
      -i|--docker-image)
        BUILD_IN_DOCKER_IMAGE="true"
        shift # past argument
        ;;
      -n|--no-docker)
        USE_DOCKER="false"
        shift # past argument
        ;;
      -p|--push)
        USE_DOCKER_PUSH="true"
        shift # past argument
        ;;
      -h|--help)
        echo "$0 <package> [arguments]"
        echo "  --docker-image (-i) - builds ports in a Dockerfile (./build).  Allows caching.  Used for build server and troubleshooting build server"
        echo "  --no-docker (-n) - Runs ./build script directly without docker overhead.  For troubleshooting and internal use as part of --docker-image"
        echo "  --push (-p) - pushes docker images.  Meant for build server"
        exit 1
        ;;
      *)    # unknown option
        ARGS+=("$1") # save it in an array for later
        shift # past argument
        ;;
    esac
  done
}

# don't run anything if being sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  PACKAGE=$1
  echo "building package: $PACKAGE"
  shift
  parse_args "$@"
  
    
  if [[ -z "$BUILD_PLATFORM" ]]; then
    BUILD_PLATFORM="linux/arm64/v8"
  fi
  echo "BUILD_IN_DOCKER_IMAGE: ${BUILD_IN_DOCKER_IMAGE} USE_DOCKER: ${USE_DOCKER} USE_DOCKER_PUSH: ${USE_DOCKER_PUSH} BUILD_PLATFORM: ${BUILD_PLATFORM}"
  DOCKER_IMAGE=${IMAGE_BASE}/${PACKAGE}:${BRANCH}

  build_env_docker_image "$PACKAGE"
  build_package "$PACKAGE"
  
  source "${PACKAGE}/package.info"
  pushd "${PACKAGE}/pkg" &> /dev/null
  mkdir -p "../../release"
  rm -rf "../../release/${PKG_NAME}"
  rm -rf "../../release/${PKG_NAME}.zip"
  cp -r "./" "../../release/${PKG_NAME}"
  zip -r "../../release/${PKG_NAME}.zip" .
  popd &> /dev/null

  echo "build done"
fi
