#!/bin/bash
set -e
BRANCH=main
IMAGE_BASE=ghcr.io/pkegg/portmaster

function build_package() {
  local PACKAGE
  PACKAGE="$1"
  local PACKAGE_DIR
  PACKAGE_DIR="$(realpath "${PACKAGE}")"
  local PACKAGE_MK="${PACKAGE}/package.info"
  local SOURCE_DIR="${PACKAGE}/source"
  local SOURCE_DOCKER_DIR=source
  local BUILD_DIR=".."
  export CCACHE_DIR="../.ccache"
  
  if [[ -z "$PACKAGE" ]]; then
    echo "Please specify package: $0 <package>"
    exit 1
  elif [[ ! -d "$PACKAGE" ]]; then
    echo "Please specify a package directory that exists.  Not: $PACKAGE"
    exit 1
  elif [[ ! -f "$PACKAGE_MK" ]]; then
    echo "No package.mk found at: $PACKAGE_MK"
    exit 1
  fi
  GET_HANDLER_SUPPORT=""
  PKG_VERSION=""
  PKG_URL=""
  BUILD_PLATFORM=""
  source "${PACKAGE_MK}"
  
  if [[ "${GET_HANDLER_SUPPORT}" == "git" ]]; then
  
     if [[ -a "${PKG_VERSION}" ]]; then
       echo "${PKG_VERSION} required"
       exit 1
     fi
     ALREADY_CLONED=false
     if [[ -d "${SOURCE_DIR}" ]]; then
        pushd "${SOURCE_DIR}" &> /dev/null
        if [[ "$(git config --get remote.origin.url)" == "$PKG_URL" ]]; then
          git fetch
          ALREADY_CLONED="true"
        fi
        popd &> /dev/null
     fi
     if [[ "$ALREADY_CLONED" == "false" ]]; then
        rm -rf "${SOURCE_DIR}"
        git clone --recursive "${PKG_URL}" "${SOURCE_DIR}"
     fi
  
     echo "Checking out: ${PKG_VERSION}"
     pushd "${SOURCE_DIR}" &> /dev/null
     git submodule update --init --recursive
     git clean -f
     git checkout "${PKG_VERSION}"
     popd &> /dev/null
  elif [[ -z "${GET_HANDLER_SUPPORT}" ]]; then
    SOURCE_DIR="${PACKAGE}"
    SOURCE_DOCKER_DIR=""
    BUILD_DIR="."
    echo "No GET_HANDLER_SUPPORT.  Assuming all local files"
  else
    echo "Handler: '${GET_HANDLER_SUPPORT}' not found"
    exit 1
  fi
  
  if [[ -z "$BUILD_PLATFORM" ]]; then
    BUILD_PLATFORM="linux/arm64/v8"
  fi
  if [[ -f "${PACKAGE}/Dockerfile" ]]; then
    echo "${PACKAGE}/Dockerfile exists"

    DOCKER_IMAGE=${IMAGE_BASE}/${PACKAGE}:${BRANCH}
    DOCKER_IMAGE_CACHE=${IMAGE_BASE}/${PACKAGE}/cache:${BRANCH}
  
    if [[ "${USE_DOCKER_PUSH}" == "true" ]]; then
      IMAGE_CACHE_TO="--pull --cache-to=type=registry,ref=${DOCKER_IMAGE_CACHE},mode=max --push"
    else
      IMAGE_CACHE_TO="--load --builder default"
    fi
    IMAGE_CACHE_FROM="--cache-from=type=registry,ref=${DOCKER_IMAGE_CACHE}"


    #make lower case as docker must be lowers
    DOCKER_IMAGE=$(echo "$DOCKER_IMAGE" | tr '[:upper:]' '[:lower:]')

    echo "docker image: ${DOCKER_IMAGE}"

    if [[ "${USE_DOCKER}" != "false" ]]; then
      pushd "${PACKAGE}" &> /dev/null
      echo docker buildx build --platform ${BUILD_PLATFORM} \
        --tag "${DOCKER_IMAGE}" \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .

      docker buildx build --platform ${BUILD_PLATFORM} \
        --tag "${DOCKER_IMAGE}" \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .
      popd &> /dev/null
      echo "tagged: ${DOCKER_IMAGE}"
    fi 
  else
    echo "${PACKAGE}/Dockerfile does not exist"
    DOCKER_IMAGE=${IMAGE_BASE}:main
  fi
  rm -rf ./pkg

  if [[ "${BUILD_IN_DOCKER_IMAGE}" == "true" ]]; then
    echo "Copying $(realpath ${PACKAGE}/../Dockerfile.build)"
    cp ${PACKAGE}/../Dockerfile.build.template ${PACKAGE}/Dockerfile.build

    DOCKER_IMAGE_BUILD=${IMAGE_BASE}/${PACKAGE}/build
    DOCKER_IMAGE_BUILD_CACHE=${IMAGE_BASE}/${PACKAGE}/build/cache

    #make lower case as docker must be lowers
    DOCKER_IMAGE_BUILD=$(echo "$DOCKER_IMAGE_BUILD" | tr '[:upper:]' '[:lower:]')
    DOCKER_IMAGE_BUILD_CACHE=$(echo "$DOCKER_IMAGE_BUILD_CACHE" | tr '[:upper:]' '[:lower:]')

    if [[ "${USE_DOCKER_PUSH}" == "true" ]]; then
      IMAGE_CACHE_TO="--pull --cache-to=type=registry,ref=${DOCKER_IMAGE_BUILD_CACHE},mode=max --push"
    fi
    IMAGE_CACHE_FROM="--cache-from=type=registry,ref=${DOCKER_IMAGE_BUILD_CACHE}"

    pushd "${PACKAGE}" &> /dev/null
    echo docker buildx build --platform ${BUILD_PLATFORM} \
        -f Dockerfile.build --tag "${DOCKER_IMAGE_BUILD}" \
        --build-arg DOCKER_IMAGE=${DOCKER_IMAGE} \
        --build-arg PACKAGE=${PACKAGE} \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .
    docker buildx build --platform ${BUILD_PLATFORM} \
        -f Dockerfile.build --tag "${DOCKER_IMAGE_BUILD}" \
        --build-arg DOCKER_IMAGE=${DOCKER_IMAGE} \
        --build-arg PACKAGE=${PACKAGE} \
        ${IMAGE_CACHE_FROM} \
        ${IMAGE_CACHE_TO} .

    
    ID=$(docker create ${DOCKER_IMAGE})
    rm -rf ./pkg
    docker cp "${ID}:/${PACKAGE}/pkg" ./pkg || true # it is OK (at least for now) if there's not a package inside
    docker rm -f "${ID}"

    popd &> /dev/null
  elif [[ -x "${BUILD_DIR}/build" || -x "${BUILD_DIR}/package" ]]; then
    
    if [[ -z "${DOCKER_WORK_DIR}" ]]; then
      DOCKER_WORK_DIR=/work
    fi
    
    GID=$(id -g)
    DOCKER_CMD=docker
  
    # Use 'sudo' if docker ps doesn't work.  In theory, other things than missing sudo could cause this.  But sudo needed is a common issue and easy to fix.
    SUDO=""
    if ! docker ps -q &> /dev/null && sudo docker ps -q &> /dev/null; then
     SUDO="sudo"
    fi
    
    # Launch docker as interactive if this is an interactive shell (allows ctrl-c for manual and running non-interactive - aka: build server)
    INTERACTIVE=""
    if [ -t 0 ]; then
      INTERACTIVE="-it"
    fi
    
    pushd "${SOURCE_DIR}" &> /dev/null
  
    if [[ -x "${BUILD_DIR}/build" ]]; then
      if [[ "${USE_DOCKER}" == "false" ]]; then
        echo "building ${PACKAGE} without docker..."
        
        "${BUILD_DIR}/build"
      else
        echo "building ${PACKAGE} with docker..."
        # Get .env file ready
        env | grep "=" > .env
        ${SUDO} ${DOCKER_CMD} run --platform ${BUILD_PLATFORM} ${PODMAN_ARGS} ${INTERACTIVE} --env-file .env --rm --user ${UID}:"${GID}" -v "${PWD}/${BUILD_DIR}:${DOCKER_WORK_DIR}" -w "${DOCKER_WORK_DIR}/${SOURCE_DOCKER_DIR}" ${DOCKER_IMAGE} bash -c "${BUILD_DIR}/build"
      fi
      echo "build done"
    fi
    if [[ -x "${BUILD_DIR}/package" ]]; then
      echo "packaging ${PACKAGE}..."
      "${BUILD_DIR}/package"
      echo "package done"
    fi
    popd &> /dev/null
  fi

  mkdir -p "${PACKAGE_DIR}/pkg"

  if [[ -f "${PACKAGE_DIR}/run.sh" ]]; then
    cp --no-clobber "${PACKAGE_DIR}/run.sh" "${PACKAGE_DIR}/pkg/${PKG_NAME}.sh"
  fi
  cp -r --no-clobber ${PACKAGE_DIR}/../_global/* "${PACKAGE_DIR}/pkg/"

  if [[ -x "${PACKAGE_DIR}/package" ]]; then
    echo "Running custom package script"
    ${PACKAGE_DIR}/package
  fi
  pushd "${PACKAGE_DIR}/pkg" &> /dev/null
  mkdir -p "$(realpath ${PACKAGE_DIR}/../release)"
  zip -FS -q -r "$(realpath "${PACKAGE_DIR}/../release/${PKG_NAME}.zip")" .
  popd &> /dev/null
  
}

function parse_args() {
  BUILD_IN_DOCKER_IMAGE=false
  USE_DOCKER=true
  USE_DOCKER_PUSH=false
  
  # Parse args
  ARGS=()
  while [[ $# -gt 0 ]]; do
    key="$1"
  
    case $key in
      -i|--docker-image)
        BUILD_IN_DOCKER_IMAGE="true"
        shift # past argument
        ;;
      -n|--no-docker)
        USE_DOCKER="false"
        shift # past argument
        ;;
      -p|--push)
        USE_DOCKER_PUSH="true"
        shift # past argument
        ;;
      -h|--help)
        echo "$0 <package> [arguments]"
        echo "  --docker-image (-i) - builds ports in a Dockerfile (./build).  Allows caching.  Used for build server and troubleshooting build server"
        echo "  --no-docker (-n) - Runs ./build script directly without docker overhead.  For troubleshooting and internal use as part of --docker-image"
        echo "  --push (-p) - pushes docker images.  Meant for build server"
        exit 1
        ;;
      *)    # unknown option
        ARGS+=("$1") # save it in an array for later
        shift # past argument
        ;;
    esac
  done
}

# don't run anything if being sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  PACKAGE=$1
  echo "building package: $PACKAGE"
  shift
  parse_args "$@"
  
  echo "BUILD_IN_DOCKER_IMAGE: ${BUILD_IN_DOCKER_IMAGE} USE_DOCKER: ${USE_DOCKER} USE_DOCKER_PUSH: ${USE_DOCKER_PUSH}"
  
  build_package "$PACKAGE"
  echo "build done"
fi